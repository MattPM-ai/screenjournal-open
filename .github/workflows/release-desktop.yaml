# Release Desktop App Workflow
#
# Builds and publishes the ScreenJournal Open desktop app for all platforms.
# This version bundles all services (databases, backends, frontend) into a standalone app.
# Triggers on version tags (v*.*.*) or manual dispatch.
#
# Required secrets for Apple signing:
#   APPLE_CERTIFICATE - Base64-encoded .p12 certificate (base64 -i certificate.p12)
#   APPLE_CERTIFICATE_PASSWORD - Password for the .p12 file
#   APPLE_SIGNING_IDENTITY - "Developer ID Application: Chomtana CHANJARASWICHAI (2N4Z8N5N6A)"
#   APPLE_TEAM_ID - 10-character team ID: 2N4Z8N5N6A
#
# Optional secrets for notarization (choose one method):
#   Method 1 - App Store Connect API (.p8 file - recommended):
#     APPLE_API_ISSUER - Issuer ID (e.g., dd1c48ce-76d2-4342-a073-cfc2319777d4)
#     APPLE_API_KEY - Key ID (e.g., DNJQ5M8CAT)
#     APPLE_API_KEY_BASE64 - Base64-encoded .p8 file content (base64 -i AuthKey_*.p8)
#   Method 2 - Apple ID credentials:
#     APPLE_ID - Apple ID email
#     APPLE_PASSWORD - App-specific password (from appleid.apple.com)
#
# Required secrets for Windows signing (add when ready):
#   WINDOWS_CERTIFICATE - Base64-encoded certificate
#   WINDOWS_CERTIFICATE_PASSWORD - Certificate password

name: Release Desktop App

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.0)'
        required: true
        type: string

env:
  CARGO_TERM_COLOR: always

jobs:
  # =============================================================================
  # Create GitHub Release (Draft)
  # =============================================================================
  create-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      release_id: ${{ steps.create-release.outputs.result }}
      version: ${{ steps.version.outputs.version }}
    steps:
      - uses: actions/checkout@v4

      - name: Get version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "version=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
          fi

      - name: Create Release
        id: create-release
        uses: actions/github-script@v7
        with:
          script: |
            const { data } = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: `v${{ steps.version.outputs.version }}`,
              name: `ScreenJournal Open v${{ steps.version.outputs.version }}`,
              body: `## ScreenJournal Open v${{ steps.version.outputs.version }}\n\nDownload the installer for your platform below.\n\n### Installation\n- **macOS**: Download the .dmg file and drag to Applications\n- **Windows**: Download and run the .exe installer or extract the .zip file\n\n**Note**: Linux builds are currently unavailable due to dependency compatibility issues.`,
              draft: true,
              prerelease: false
            })
            return data.id

  # =============================================================================
  # Build for All Platforms
  # =============================================================================
  build:
    needs: create-release
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          # macOS (build script handles both arm64 and x64)
          - platform: macos-latest
            build_script: './build-bundled.sh'
            artifact_name: macOS-universal
            artifact_pattern: 'screenjournal/apps/desktop/src-tauri/target/release/bundle/dmg/*.dmg'
          # Linux - Currently skipped due to libspa/PipeWire compatibility issues
          # - platform: ubuntu-22.04
          #   build_script: './build-bundled-linux.sh'
          #   artifact_name: Linux-x64
          #   artifact_pattern: 'screenjournal/apps/desktop/src-tauri/target/release/bundle/deb/*.deb'
          # Windows
          - platform: windows-latest
            build_script: './build-bundled-windows.sh'
            artifact_name: Windows-x64

    runs-on: ${{ matrix.platform }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'
          cache-dependency-path: |
            sj-collector/go.sum
            sj-tracker-report/go.sum

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './screenjournal/apps/desktop/src-tauri -> target'

      # =========================================================================
      # Platform-specific dependencies
      # =========================================================================
      - name: Install Linux dependencies
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf \
            libssl-dev \
            libpipewire-0.3-dev \
            ffmpeg \
            dpkg-dev

      - name: Install macOS dependencies
        if: matrix.platform == 'macos-latest'
        run: |
          brew install ffmpeg || true

      - name: Install Windows dependencies
        if: matrix.platform == 'windows-latest'
        run: |
          # Windows dependencies are typically pre-installed in GitHub Actions
          # Visual Studio Build Tools should be available
          echo "Windows dependencies should be pre-installed"

      # =========================================================================
      # Install npm dependencies
      # =========================================================================
      - name: Install root dependencies
        run: npm ci
        working-directory: screenjournal

      - name: Install desktop dependencies
        run: npm ci
        working-directory: screenjournal/apps/desktop

      - name: Install frontend dependencies
        run: npm ci
        working-directory: sj-tracker-frontend

      # =========================================================================
      # Build monorepo packages (UI package needed by desktop app)
      # =========================================================================
      - name: Build UI package
        run: npm run build --workspace=@repo/ui
        working-directory: screenjournal

      # =========================================================================
      # Setup ActivityWatch and FFmpeg binaries (required for desktop app)
      # =========================================================================
      - name: Setup ActivityWatch
        run: npm run setup-aw
        working-directory: screenjournal/apps/desktop

      - name: Setup FFmpeg
        run: npm run setup-ffmpeg
        working-directory: screenjournal/apps/desktop

      # =========================================================================
      # Import Apple Code Signing Certificate (macOS only)
      # =========================================================================
      - name: Import Apple Certificate
        if: matrix.platform == 'macos-latest' && env.APPLE_CERTIFICATE != ''
        run: |
          echo "üîê Importing Apple Developer ID certificate..."
          # Create temporary keychain for certificate
          KEYCHAIN_NAME="build.keychain"
          KEYCHAIN_PASSWORD=$(openssl rand -base64 12)
          
          # Create keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          security set-keychain-settings -t 3600 -u "$KEYCHAIN_NAME"
          security list-keychains -d user -s "$KEYCHAIN_NAME" $(security list-keychains -d user | sed 's/^[ ]*"\(.*\)".*$/\1/' | tr '\n' ' ')
          
          # Decode and import certificate
          echo "$APPLE_CERTIFICATE" | base64 --decode > certificate.p12
          security import certificate.p12 -k "$KEYCHAIN_NAME" -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign
          
          # Trust the certificate
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          
          # Verify certificate is accessible
          security find-identity -v -p codesigning "$KEYCHAIN_NAME" || true
          
          echo "‚úÖ Certificate imported successfully"
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}

      # =========================================================================
      # Setup App Store Connect API Key (.p8 file) for Notarization (macOS only)
      # =========================================================================
      - name: Setup App Store Connect API Key
        if: matrix.platform == 'macos-latest'
        run: |
          echo "üîë Setting up App Store Connect API key for notarization..."
          
          # Check if API credentials are provided
          if [ -z "$APPLE_API_KEY" ] || [ -z "$APPLE_API_ISSUER" ]; then
            echo "‚ö†Ô∏è  App Store Connect API credentials not provided, skipping notarization setup"
            exit 0
          fi
          
          # Create directory for API key (using $HOME for GitHub Actions compatibility)
          API_KEY_DIR="$HOME/.appstoreconnect/private_keys"
          mkdir -p "$API_KEY_DIR"
          
          # Determine the API key file path (Tauri expects: AuthKey_<KEY_ID>.p8)
          API_KEY_FILE="$API_KEY_DIR/AuthKey_${APPLE_API_KEY}.p8"
          
          # If APPLE_API_KEY_BASE64 is provided, decode it and write to file
          if [ -n "$APPLE_API_KEY_BASE64" ]; then
            echo "$APPLE_API_KEY_BASE64" | base64 --decode > "$API_KEY_FILE"
            echo "‚úÖ Decoded .p8 file from base64 secret"
          else
            echo "‚ùå APPLE_API_KEY_BASE64 not provided"
            echo "   Please add APPLE_API_KEY_BASE64 secret with base64-encoded .p8 file content"
            exit 1
          fi
          
          # Set secure permissions (read/write for owner only)
          chmod 600 "$API_KEY_FILE"
          
          # Verify file was created
          if [ ! -f "$API_KEY_FILE" ]; then
            echo "‚ùå Failed to create API key file"
            exit 1
          fi
          
          # Export the path for Tauri to use (this will be available in subsequent steps)
          echo "APPLE_API_KEY_PATH=${API_KEY_FILE}" >> $GITHUB_ENV
          echo "‚úÖ API key setup complete"
          echo "üìç API key path: ${API_KEY_FILE}"
          echo "üìç Issuer ID: ${APPLE_API_ISSUER}"
          echo "üìç Key ID: ${APPLE_API_KEY}"
        env:
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
          APPLE_API_KEY_BASE64: ${{ secrets.APPLE_API_KEY_BASE64 }}

      # =========================================================================
      # Make build script executable and run it
      # =========================================================================
      - name: Make build script executable
        if: matrix.platform != 'windows-latest'
        run: chmod +x ${{ matrix.build_script }}

      - name: Run bundled build script (Unix)
        if: matrix.platform != 'windows-latest'
        shell: bash
        run: ${{ matrix.build_script }}
        env:
          # Gemini API key - embedded at build time if needed
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          # Apple signing - configure these secrets in GitHub repository settings
          # APPLE_CERTIFICATE: Base64-encoded .p12 certificate file
          # APPLE_CERTIFICATE_PASSWORD: Password for the .p12 file
          # APPLE_SIGNING_IDENTITY: "Developer ID Application: Chomtana CHANJARASWICHAI (2N4Z8N5N6A)"
          # APPLE_ID: Apple ID email for notarization (optional)
          # APPLE_PASSWORD: App-specific password for notarization (optional)
          # APPLE_TEAM_ID: 10-character team ID (2N4Z8N5N6A)
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          # Notarization: App Store Connect API (uses .p8 file)
          # Tauri will use these if provided (see Tauri docs: https://tauri.app/distribute/sign/macos)
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_KEY_PATH: ${{ env.APPLE_API_KEY_PATH }}

      - name: Run bundled build script (Windows)
        if: matrix.platform == 'windows-latest'
        shell: bash
        run: bash ${{ matrix.build_script }}
        env:
          # Gemini API key - embedded at build time if needed
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          # Windows signing - uncomment when certificate is configured
          # WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          # WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}

      # =========================================================================
      # Upload artifacts to release
      # =========================================================================
      - name: Find and upload macOS DMG
        if: matrix.platform == 'macos-latest'
        uses: actions/github-script@v7
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_ID: ${{ needs.create-release.outputs.release_id }}
          VERSION: ${{ needs.create-release.outputs.version }}
          ARTIFACT_NAME: ${{ matrix.artifact_name }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');
            
            // Find DMG file
            const dmgPattern = 'screenjournal/apps/desktop/src-tauri/target/release/bundle/dmg/*.dmg';
            const dmgFiles = execSync(`find screenjournal/apps/desktop/src-tauri/target -name "*.dmg" -type f`, { encoding: 'utf-8' }).trim().split('\n').filter(f => f);
            
            if (dmgFiles.length === 0) {
              throw new Error('No DMG file found');
            }
            
            const dmgPath = dmgFiles[0];
            const dmgName = `ScreenJournal-Open-${process.env.ARTIFACT_NAME}-${process.env.VERSION}.dmg`;
            
            console.log(`Uploading ${dmgPath} as ${dmgName}`);
            
            const { data } = await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: parseInt(process.env.RELEASE_ID),
              name: dmgName,
              data: fs.readFileSync(dmgPath),
              headers: {
                'content-type': 'application/x-apple-diskimage',
                'content-length': fs.statSync(dmgPath).size
              }
            });
            
            console.log(`Uploaded: ${data.browser_download_url}`);

      # Linux DEB upload - Currently skipped due to libspa/PipeWire compatibility issues
      # - name: Find and upload Linux DEB
      #   if: matrix.platform == 'ubuntu-22.04'
      #   uses: actions/github-script@v7
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #     RELEASE_ID: ${{ needs.create-release.outputs.release_id }}
      #     VERSION: ${{ needs.create-release.outputs.version }}
      #     ARTIFACT_NAME: ${{ matrix.artifact_name }}
      #   with:
      #     script: |
      #       const fs = require('fs');
      #       const { execSync } = require('child_process');
      #       
      #       // Find DEB file
      #       const debFiles = execSync(`find screenjournal/apps/desktop/src-tauri/target -name "*.deb" -type f`, { encoding: 'utf-8' }).trim().split('\n').filter(f => f);
      #       
      #       if (debFiles.length === 0) {
      #         throw new Error('No DEB file found');
      #       }
      #       
      #       const debPath = debFiles[0];
      #       const debName = `ScreenJournal-Open-${process.env.ARTIFACT_NAME}-${process.env.VERSION}.deb`;
      #       
      #       console.log(`Uploading ${debPath} as ${debName}`);
      #       
      #       const { data } = await github.rest.repos.uploadReleaseAsset({
      #         owner: context.repo.owner,
      #         repo: context.repo.repo,
      #         release_id: parseInt(process.env.RELEASE_ID),
      #         name: debName,
      #         data: fs.readFileSync(debPath),
      #         headers: {
      #           'content-type': 'application/vnd.debian.binary-package',
      #           'content-length': fs.statSync(debPath).size
      #         }
      #       });
      #       
      #       console.log(`Uploaded: ${data.browser_download_url}`);

      - name: Find and upload Windows installer
        if: matrix.platform == 'windows-latest'
        uses: actions/github-script@v7
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_ID: ${{ needs.create-release.outputs.release_id }}
          VERSION: ${{ needs.create-release.outputs.version }}
          ARTIFACT_NAME: ${{ matrix.artifact_name }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Recursive function to find files matching pattern
            function findFiles(dir, pattern, fileList = []) {
              if (!fs.existsSync(dir)) {
                return fileList;
              }
              
              const files = fs.readdirSync(dir);
              
              for (const file of files) {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                
                if (stat.isDirectory()) {
                  findFiles(filePath, pattern, fileList);
                } else if (stat.isFile() && pattern.test(file)) {
                  fileList.push(filePath);
                }
              }
              
              return fileList;
            }
            
            // Try to find .exe installer first (in nsis directory)
            let installerPath = null;
            let installerName = null;
            let contentType = 'application/x-msdownload';
            
            const targetDir = path.join('screenjournal', 'apps', 'desktop', 'src-tauri', 'target');
            
            // Look for .exe files in nsis subdirectories
            const exeFiles = findFiles(targetDir, /\.exe$/i).filter(p => 
              p.toLowerCase().includes('nsis') || p.toLowerCase().includes('installer')
            );
            
            if (exeFiles.length > 0) {
              installerPath = exeFiles[0];
              installerName = `ScreenJournal-Open-${process.env.ARTIFACT_NAME}-${process.env.VERSION}.exe`;
            } else {
              console.log('No .exe installer found, trying zip...');
              
              // Fallback to zip files
              const zipFiles = findFiles(targetDir, /\.zip$/i);
              
              if (zipFiles.length > 0) {
                installerPath = zipFiles[0];
                installerName = `ScreenJournal-Open-${process.env.ARTIFACT_NAME}-${process.env.VERSION}.zip`;
                contentType = 'application/zip';
              } else {
                throw new Error('No installer or zip file found');
              }
            }
            
            console.log(`Found installer: ${installerPath}`);
            console.log(`Uploading as ${installerName}`);
            
            const { data } = await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: parseInt(process.env.RELEASE_ID),
              name: installerName,
              data: fs.readFileSync(installerPath),
              headers: {
                'content-type': contentType,
                'content-length': fs.statSync(installerPath).size
              }
            });
            
            console.log(`Uploaded: ${data.browser_download_url}`);

  # =============================================================================
  # Publish Release (after all builds complete)
  # =============================================================================
  publish-release:
    runs-on: ubuntu-latest
    needs: [create-release, build]
    permissions:
      contents: write
    steps:
      - name: Publish Release
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ needs.create-release.outputs.release_id }}
        with:
          script: |
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: process.env.RELEASE_ID,
              draft: false
            })
            console.log(`Published release ${process.env.RELEASE_ID}`)
