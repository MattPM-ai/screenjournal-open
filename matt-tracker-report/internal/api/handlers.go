package api

import (
	"fmt"
	"matt-tracker-report/internal/database"
	"matt-tracker-report/internal/models"
	"matt-tracker-report/internal/services"
	"matt-tracker-report/internal/utils"
	"net/http"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
)

// Handlers contains all HTTP handlers
type Handlers struct {
	reportService     *services.ReportService
	taskService       *services.TaskService
	weeklyEmailService *services.WeeklyEmailService
	mongoClient       *database.MongoDBClient
	chatTools         *services.ChatTools
}

// NewHandlers creates a new handlers instance
func NewHandlers(
	reportService *services.ReportService,
	taskService *services.TaskService,
	weeklyEmailService *services.WeeklyEmailService,
	mongoClient *database.MongoDBClient,
	chatTools *services.ChatTools,
) *Handlers {
	return &Handlers{
		reportService:      reportService,
		taskService:        taskService,
		weeklyEmailService: weeklyEmailService,
		mongoClient:        mongoClient,
		chatTools:          chatTools,
	}
}

// GenerateReportHandler handles POST /api/reports/generate
func (h *Handlers) GenerateReportHandler(c *gin.Context) {
	var req models.GenerateReportRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Check MongoDB cache - if report is cached, create a task with it immediately
	cachedReport, err := h.reportService.GetCachedReport(req)
	if err == nil && cachedReport != nil {
		// Create task and mark it as completed with cached report
		task, err := h.taskService.CreateTask(req)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create task"})
			return
		}

		// Set the cached report immediately
		_ = h.taskService.SetTaskReport(task.ID, cachedReport)

		// Return task ID
		c.JSON(http.StatusOK, models.TaskResponse{
			TaskID: task.ID,
			Status: string(models.TaskStatusCompleted),
		})
		return
	}

	// No existing task or cache - create new task and start async generation
	task, err := h.taskService.CreateTask(req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create task"})
		return
	}

	// Start async report generation
	go func() {
		// Update status to processing
		_ = h.taskService.UpdateTaskStatus(task.ID, models.TaskStatusProcessing)

		// Generate report (this will check cache internally and cache the result)
		report, err := h.reportService.GenerateReport(req)
		if err != nil {
			_ = h.taskService.SetTaskError(task.ID, err)
			return
		}

		// Store report in task
		_ = h.taskService.SetTaskReport(task.ID, report)
	}()

	// Return task ID immediately
	c.JSON(http.StatusAccepted, models.TaskResponse{
		TaskID: task.ID,
		Status: string(task.Status),
	})
}

// GenerateReportSyncHandler handles POST /api/reports/generate-sync
// Synchronously generates and returns the report (waits for completion)
func (h *Handlers) GenerateReportSyncHandler(c *gin.Context) {
	var req models.GenerateReportRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Generate report synchronously (this will check cache internally)
	report, err := h.reportService.GenerateReport(req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Return the complete report directly
	c.JSON(http.StatusOK, report)
}

// GetTaskStatusHandler handles GET /api/reports/status/:taskId
func (h *Handlers) GetTaskStatusHandler(c *gin.Context) {
	taskID := c.Param("taskId")
	if taskID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "taskId is required"})
		return
	}

	task, err := h.taskService.GetTask(taskID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "task not found"})
		return
	}

	response := models.StatusResponse{
		TaskID: task.ID,
		Status: string(task.Status),
	}

	if task.Status == models.TaskStatusCompleted {
		response.Report = task.Report
	} else if task.Status == models.TaskStatusFailed {
		response.Error = task.Error
	}

	c.JSON(http.StatusOK, response)
}

// GenerateWeeklyReportHandler handles POST /api/reports/generate-weekly
func (h *Handlers) GenerateWeeklyReportHandler(c *gin.Context) {
	var req models.GenerateWeeklyReportRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Calculate week range for cache key
	weekStartDate, err := utils.ParseDate(req.WeekStartDate)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid week start date"})
		return
	}
	monday, sunday := utils.CalculateWeekRange(weekStartDate)
	startDateStr := utils.FormatDate(monday)
	endDateStr := utils.FormatDate(sunday)

	// Check MongoDB cache for weekly reports - if report is cached, create a task with it immediately
	cachedReport, err := h.reportService.GetCachedWeeklyReport(req)
	if err == nil && cachedReport != nil {
		// Create task and mark it as completed with cached report
		// Create a temporary GenerateReportRequest for task creation
		tempRequest := models.GenerateReportRequest{
			AccountID: req.AccountID,
			Users:     req.Users,
			Org:       req.Org,
			OrgID:     req.OrgID,
			StartDate: startDateStr,
			EndDate:   endDateStr,
		}
		task, err := h.taskService.CreateTask(tempRequest)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create task"})
			return
		}

		// Set the cached report immediately
		_ = h.taskService.SetTaskReport(task.ID, cachedReport)

		// Return task ID
		c.JSON(http.StatusOK, models.TaskResponse{
			TaskID: task.ID,
			Status: string(models.TaskStatusCompleted),
		})
		return
	}

	// No existing task or cache - create new task and start async generation
	// Create a temporary GenerateReportRequest for task creation
	tempRequest := models.GenerateReportRequest{
		AccountID: req.AccountID,
		Users:     req.Users,
		Org:       req.Org,
		OrgID:     req.OrgID,
		StartDate: startDateStr,
		EndDate:   endDateStr,
	}
	task, err := h.taskService.CreateTask(tempRequest)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create task"})
		return
	}

	// Start async weekly report generation
	go func() {
		// Update status to processing
		_ = h.taskService.UpdateTaskStatus(task.ID, models.TaskStatusProcessing)

		// Generate weekly report (this will check cache internally and cache the result)
		report, err := h.reportService.GenerateWeeklyReport(req)
		if err != nil {
			_ = h.taskService.SetTaskError(task.ID, err)
			return
		}

		// Store report in task
		_ = h.taskService.SetTaskReport(task.ID, report)
	}()

	// Return task ID immediately
	c.JSON(http.StatusAccepted, models.TaskResponse{
		TaskID: task.ID,
		Status: string(task.Status),
	})
}

// GenerateWeeklyReportSyncHandler handles POST /api/reports/generate-weekly-sync
// Synchronously generates and returns the weekly report (waits for completion)
func (h *Handlers) GenerateWeeklyReportSyncHandler(c *gin.Context) {
	var req models.GenerateWeeklyReportRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Generate weekly report synchronously (this will check cache internally)
	report, err := h.reportService.GenerateWeeklyReportSync(req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Return the complete report directly
	c.JSON(http.StatusOK, report)
}

// OptInWeeklyReportsHandler handles POST /api/reports/weekly/opt-in
func (h *Handlers) OptInWeeklyReportsHandler(c *gin.Context) {
	var req models.OptInWeeklyReportsRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if h.mongoClient == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "MongoDB client not available"})
		return
	}

	if h.weeklyEmailService == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Weekly email service not available"})
		return
	}

	// Parse optional trigger time
	var nextTriggerTime *time.Time
	if req.NextTriggerTime != nil && *req.NextTriggerTime != "" {
		parsedTime, err := time.Parse(time.RFC3339, *req.NextTriggerTime)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("invalid nextTriggerTime format: %v. Use ISO 8601 format (e.g., 2025-01-15T14:30:00Z)", err)})
			return
		}
		nextTriggerTime = &parsedTime
	}

	// Add to MongoDB
	err := h.mongoClient.AddOptedAccount(req.AccountID, req.OrgID, req.OrgName, req.Email, req.Users, nextTriggerTime)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to opt in: %v", err)})
		return
	}

	// Schedule the cron job
	_, err = h.weeklyEmailService.ScheduleWeeklyReport(req.AccountID, req.OrgID, req.OrgName, req.Email, nextTriggerTime)
	if err != nil {
		// Log error but don't fail - the account is still opted in
		fmt.Printf("WARNING: Failed to schedule weekly report for account %d, org %d: %v\n", req.AccountID, req.OrgID, err)
		c.JSON(http.StatusOK, gin.H{
			"message": "Opted in successfully, but failed to schedule cron job",
			"error":   err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":   "Successfully opted in to weekly reports",
		"accountId": req.AccountID,
		"orgId":     req.OrgID,
	})
}

// OptOutWeeklyReportsHandler handles POST /api/reports/weekly/opt-out
func (h *Handlers) OptOutWeeklyReportsHandler(c *gin.Context) {
	var req models.OptOutWeeklyReportsRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if h.mongoClient == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "MongoDB client not available"})
		return
	}

	// Remove from MongoDB
	err := h.mongoClient.RemoveOptedAccount(req.AccountID, req.OrgID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to opt out: %v", err)})
		return
	}

	// Note: We can't easily unschedule a specific cron without storing entry IDs
	// For now, we'll just remove from MongoDB. On next server restart, it won't be scheduled.
	// TODO: Store cron entry IDs in MongoDB for proper unscheduling

	c.JSON(http.StatusOK, gin.H{
		"message":   "Successfully opted out of weekly reports",
		"accountId": req.AccountID,
		"orgId":     req.OrgID,
	})
}

// SendWeeklyReportEmailHandler handles POST /api/reports/weekly/send-email
// Manually sends a weekly report email for a specific week (no cron scheduling)
func (h *Handlers) SendWeeklyReportEmailHandler(c *gin.Context) {
	var req models.SendWeeklyReportEmailRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if h.weeklyEmailService == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Weekly email service not available"})
		return
	}

	// Send the email asynchronously
	go func() {
		err := h.weeklyEmailService.SendWeeklyReportEmailForWeek(
			req.AccountID,
			req.OrgID,
			req.OrgName,
			req.Email,
			req.Users,
			req.WeekStartDate,
		)
		if err != nil {
			fmt.Printf("ERROR: Failed to send weekly report email: %v\n", err)
		}
	}()

	c.JSON(http.StatusAccepted, gin.H{
		"message":   "Weekly report email generation and sending initiated",
		"accountId": req.AccountID,
		"orgId":     req.OrgID,
		"week":      req.WeekStartDate,
	})
}

// GetOptedInAccountsHandler handles GET /api/reports/weekly/opted-in/:accountId
// Returns all organizations that have opted into weekly reports for the given account
func (h *Handlers) GetOptedInAccountsHandler(c *gin.Context) {
	accountIDStr := c.Param("accountId")
	accountID, err := strconv.Atoi(accountIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid accountId"})
		return
	}

	if h.mongoClient == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "MongoDB client not available"})
		return
	}

	accounts, err := h.mongoClient.GetOptedAccountsByAccountID(accountID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to get opted accounts: %v", err)})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"accountId": accountID,
		"accounts":  accounts,
	})
}

// ListToolsHandler handles GET /api/chat/tools
// Returns list of all available tools with their schemas
func (h *Handlers) ListToolsHandler(c *gin.Context) {
	if h.chatTools == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "chat tools not initialized"})
		return
	}

	tools := h.chatTools.GetAllTools()
	toolSchemas := make([]map[string]interface{}, len(tools))

	for i, tool := range tools {
		toolSchemas[i] = map[string]interface{}{
			"name":        tool.Name,
			"description": tool.Description,
			"parameters":  tool.Parameters,
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"tools": toolSchemas,
	})
}

// ExecuteToolHandler handles POST /api/chat/tools/execute
// Executes a tool with given parameters
func (h *Handlers) ExecuteToolHandler(c *gin.Context) {
	if h.chatTools == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "chat tools not initialized"})
		return
	}

	var req struct {
		ToolName string                 `json:"tool_name" binding:"required"`
		Params   map[string]interface{} `json:"params" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Find the tool
	tools := h.chatTools.GetAllTools()
	var tool *services.Tool
	for i := range tools {
		if tools[i].Name == req.ToolName {
			tool = &tools[i]
			break
		}
	}

	if tool == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": fmt.Sprintf("tool '%s' not found", req.ToolName)})
		return
	}

	// Execute the tool
	result, err := tool.Execute(req.Params)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "tool execution failed",
			"message": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"result": result,
	})
}

