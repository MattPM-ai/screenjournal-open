/**
 * ============================================================================
 * BUILD SCRIPT: Gemini API Key Embedding
 * ============================================================================
 *
 * PURPOSE: Generate an obfuscated API key constant at compile time
 *
 * KEY SOURCE PRIORITY:
 * 1. GEMINI_API_KEY environment variable (CI/CD, manual export)
 * 2. ../.env file (local development)
 * 3. Empty placeholder (Gemini features disabled at runtime)
 *
 * SECURITY:
 * - Key is XOR obfuscated with random mask to prevent `strings` extraction
 * - Each build generates a unique obfuscation pattern
 * - Runtime can override with GEMINI_API_KEY env var
 *
 * ============================================================================
 */

use rand::Rng;
use std::env;
use std::fs;
use std::path::Path;

fn main() {
    // Load .env from apps/desktop/ (parent of src-tauri/)
    let env_path = Path::new("../.env");
    if env_path.exists() {
        dotenvy::from_path(env_path).ok();
    }

    // Get API key from environment
    let api_key = env::var("GEMINI_API_KEY").unwrap_or_default();

    // Generate obfuscated key module
    generate_embedded_key(&api_key);

    // Standard Tauri build
    tauri_build::build()
}

/**
 * Generate the embedded_key.rs module with obfuscated API key
 *
 * # Arguments
 * * `api_key` - The API key to embed (empty string if not provided)
 */
fn generate_embedded_key(api_key: &str) {
    let out_path = Path::new("src/recording/gemini/embedded_key.rs");

    // Tell Cargo to rerun if .env changes or env var changes
    println!("cargo:rerun-if-changed=../.env");
    println!("cargo:rerun-if-env-changed=GEMINI_API_KEY");

    // Check if we need to regenerate the file
    // Skip regeneration if file exists and key status matches
    if out_path.exists() {
        if let Ok(existing_content) = fs::read_to_string(out_path) {
            let has_key_in_file = existing_content.contains("pub fn has_embedded_key() -> bool {\n    true\n}");
            let should_have_key = !api_key.is_empty();
            
            // If key status matches, don't regenerate (avoids infinite rebuild loop)
            if has_key_in_file == should_have_key {
                return;
            }
        }
    }

    // Ensure parent directory exists
    if let Some(parent) = out_path.parent() {
        fs::create_dir_all(parent).ok();
    }

    let content = if api_key.is_empty() {
        // No key provided - generate placeholder module
        generate_placeholder_module()
    } else {
        // Generate XOR obfuscated key module
        generate_obfuscated_module(api_key)
    };

    // Write the generated module
    fs::write(out_path, content).expect("Failed to write embedded_key.rs");
}

/**
 * Generate placeholder module when no API key is provided
 */
fn generate_placeholder_module() -> String {
    r#"/**
 * ============================================================================
 * EMBEDDED API KEY MODULE (Generated - No Key Configured)
 * ============================================================================
 *
 * WARNING: This file is auto-generated by build.rs
 * DO NOT edit manually or commit to version control.
 *
 * No GEMINI_API_KEY was provided at build time.
 * To embed a key:
 * 1. Set GEMINI_API_KEY environment variable, OR
 * 2. Create apps/desktop/.env file with GEMINI_API_KEY=your_key
 *
 * ============================================================================
 */

/// Check if an embedded API key exists
pub fn has_embedded_key() -> bool {
    false
}

/// Get the embedded API key (returns error if not configured)
pub fn get_embedded_key() -> Result<String, String> {
    Err("No Gemini API key embedded at build time. Set GEMINI_API_KEY environment variable or create .env file.".to_string())
}
"#
    .to_string()
}

/**
 * Generate module with XOR obfuscated API key
 *
 * # Arguments
 * * `api_key` - The API key to obfuscate
 */
fn generate_obfuscated_module(api_key: &str) -> String {
    let key_bytes = api_key.as_bytes();
    let mut rng = rand::thread_rng();

    // Generate random XOR mask (same length as key)
    let mask: Vec<u8> = (0..key_bytes.len()).map(|_| rng.r#gen()).collect();

    // XOR the key with the mask
    let obfuscated: Vec<u8> = key_bytes
        .iter()
        .zip(mask.iter())
        .map(|(k, m)| k ^ m)
        .collect();

    // Format as Rust byte arrays
    let obfuscated_str = format_byte_array(&obfuscated);
    let mask_str = format_byte_array(&mask);

    format!(
        r#"/**
 * ============================================================================
 * EMBEDDED API KEY MODULE (Generated at Build Time)
 * ============================================================================
 *
 * WARNING: This file is auto-generated by build.rs
 * DO NOT edit manually or commit to version control.
 *
 * The API key is XOR obfuscated to prevent casual extraction via `strings`.
 * Runtime can override with GEMINI_API_KEY environment variable.
 *
 * ============================================================================
 */

/// XOR obfuscated API key bytes
const OBFUSCATED_KEY: [u8; {len}] = {obfuscated};

/// XOR mask for decoding
const XOR_MASK: [u8; {len}] = {mask};

/// Check if an embedded API key exists
pub fn has_embedded_key() -> bool {{
    true
}}

/// Get the embedded API key by decoding the obfuscated bytes
pub fn get_embedded_key() -> Result<String, String> {{
    let decoded: Vec<u8> = OBFUSCATED_KEY
        .iter()
        .zip(XOR_MASK.iter())
        .map(|(o, m)| o ^ m)
        .collect();

    String::from_utf8(decoded)
        .map_err(|e| format!("Failed to decode embedded API key: {{}}", e))
}}
"#,
        len = key_bytes.len(),
        obfuscated = obfuscated_str,
        mask = mask_str
    )
}

/**
 * Format a byte slice as a Rust array literal
 *
 * # Arguments
 * * `bytes` - The bytes to format
 *
 * # Returns
 * String in format "[0xAB, 0xCD, ...]"
 */
fn format_byte_array(bytes: &[u8]) -> String {
    let formatted: Vec<String> = bytes.iter().map(|b| format!("0x{:02X}", b)).collect();
    format!("[{}]", formatted.join(", "))
}
