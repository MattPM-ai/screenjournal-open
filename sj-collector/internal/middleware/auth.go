package middleware

import (
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"

	"sj-collector/internal/models"
	"sj-collector/internal/services"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
)

// JWTAuth is a middleware that validates JWT tokens and extracts claims
func JWTAuth(jwtService *services.JWTService) gin.HandlerFunc {
	return func(c *gin.Context) {
		// Extract JWT token from Authorization header
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "missing authorization header"})
			c.Abort()
			return
		}

		// Extract token (format: "Bearer <token>")
		parts := strings.Split(authHeader, " ")
		if len(parts) != 2 || parts[0] != "Bearer" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid authorization header format"})
			c.Abort()
			return
		}
		token := parts[1]

		// Validate token and extract claims
		claims, err := jwtService.ValidateToken(token)
		if err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid token"})
			c.Abort()
			return
		}

		// Validate user and org in claims
		if claims.User == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "missing user in token"})
			c.Abort()
			return
		}

		if claims.Org == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "missing org in token"})
			c.Abort()
			return
		}

		// Store user, org, and full claims in context
		c.Set("user", claims.User)
		c.Set("org", claims.Org)
		c.Set("claims", claims)

		c.Next()
	}
}

// GetUser retrieves the user from the Gin context
func GetUser(c *gin.Context) string {
	user, _ := c.Get("user")
	return user.(string)
}

// GetOrg retrieves the org from the Gin context
func GetOrg(c *gin.Context) string {
	org, _ := c.Get("org")
	return org.(string)
}

// GetClaims retrieves all JWT claims from the Gin context
func GetClaims(c *gin.Context) *models.Claims {
	claims, _ := c.Get("claims")
	return claims.(*models.Claims)
}

// GetBackendUserId retrieves the backend user ID from the Gin context
// Returns empty string if not set (user not authenticated via BackendAuth)
func GetBackendUserId(c *gin.Context) string {
	userId, exists := c.Get("backendUserId")
	if !exists {
		return ""
	}
	userIdStr, ok := userId.(string)
	if !ok {
		return ""
	}
	return userIdStr
}

// GetBackendClaims retrieves the backend token claims from the Gin context
func GetBackendClaims(c *gin.Context) *BackendTokenClaims {
	claims, exists := c.Get("backendClaims")
	if !exists {
		return nil
	}
	backendClaims, ok := claims.(*BackendTokenClaims)
	if !ok {
		return nil
	}
	return backendClaims
}

// BackendTokenClaims represents the JWT token payload structure from screenjournal-backend
// Matches the structure from screenjournal-backend (userId, email, iat, exp)
type BackendTokenClaims struct {
	UserId string `json:"userId"`
	Email  string `json:"email"`
	jwt.RegisteredClaims
}

// BackendAuth validates JWT tokens generated by screenjournal-backend
// This middleware validates tokens using the shared JWT_SECRET from environment
// It does NOT generate tokens - only validates them
func BackendAuth() gin.HandlerFunc {
	return func(c *gin.Context) {
		log.Printf("[AUTH] BackendAuth: Request received - Method=%s, Path=%s", c.Request.Method, c.Request.URL.Path)
		
		// Extract JWT token from Authorization header
		authHeader := c.GetHeader("Authorization")
		log.Printf("[AUTH] BackendAuth: Authorization header present=%v, value_length=%d", authHeader != "", len(authHeader))
		
		if authHeader == "" {
			log.Printf("[AUTH] BackendAuth: FAILED - Missing Authorization header")
			c.JSON(http.StatusUnauthorized, gin.H{
				"error":   "Unauthorized",
				"message": "Invalid or expired token",
			})
			c.Abort()
			return
		}

		// Extract token (format: "Bearer <token>")
		if !strings.HasPrefix(authHeader, "Bearer ") {
			log.Printf("[AUTH] BackendAuth: FAILED - Invalid header format (does not start with 'Bearer ')")
			c.JSON(http.StatusUnauthorized, gin.H{
				"error":   "Unauthorized",
				"message": "Invalid authorization header format",
			})
			c.Abort()
			return
		}

		token := strings.TrimPrefix(authHeader, "Bearer ")
		tokenPreview := token
		if len(token) > 20 {
			tokenPreview = token[:20] + "..."
		}
		log.Printf("[AUTH] BackendAuth: Token extracted, length=%d, preview=%s", len(token), tokenPreview)
		
		if token == "" {
			log.Printf("[AUTH] BackendAuth: FAILED - Token is empty after Bearer prefix")
			c.JSON(http.StatusUnauthorized, gin.H{
				"error":   "Unauthorized",
				"message": "Token missing",
			})
			c.Abort()
			return
		}

		// Get JWT secret from environment
		jwtSecret := os.Getenv("JWT_SECRET")
		log.Printf("[AUTH] BackendAuth: JWT_SECRET configured=%v, length=%d", jwtSecret != "", len(jwtSecret))
		
		if jwtSecret == "" {
			log.Printf("[AUTH] BackendAuth: FAILED - JWT_SECRET not configured")
			c.JSON(http.StatusInternalServerError, gin.H{
				"error":   "Internal Server Error",
				"message": "JWT_SECRET not configured",
			})
			c.Abort()
			return
		}

		// Parse and verify token
		log.Printf("[AUTH] BackendAuth: Attempting to parse and validate token...")
		parsedToken, err := jwt.ParseWithClaims(token, &BackendTokenClaims{}, func(token *jwt.Token) (interface{}, error) {
			// Validate signing method
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
			}
			return []byte(jwtSecret), nil
		})

		if err != nil {
			// Check for specific error types
			var message string
			if err == jwt.ErrTokenExpired {
				message = "Token expired"
				log.Printf("[AUTH] BackendAuth: Token validation failed - Token expired")
			} else if err == jwt.ErrTokenMalformed {
				message = "Malformed token"
				log.Printf("[AUTH] BackendAuth: Token validation failed - Malformed token")
			} else {
				message = fmt.Sprintf("Invalid token: %v", err)
				log.Printf("[AUTH] BackendAuth: Token validation failed - %v", err)
			}

			c.JSON(http.StatusUnauthorized, gin.H{
				"error":   "Unauthorized",
				"message": message,
			})
			c.Abort()
			return
		}

		// Extract and validate claims
		claims, ok := parsedToken.Claims.(*BackendTokenClaims)
		if !ok || !parsedToken.Valid {
			log.Printf("[AUTH] BackendAuth: Token validation failed - Invalid token claims (ok=%v, valid=%v)", ok, parsedToken.Valid)
			c.JSON(http.StatusUnauthorized, gin.H{
				"error":   "Unauthorized",
				"message": "Invalid token claims",
			})
			c.Abort()
			return
		}

		// Validate required fields
		if claims.UserId == "" {
			log.Printf("[AUTH] BackendAuth: Missing userId in token claims")
			c.JSON(http.StatusUnauthorized, gin.H{
				"error":   "Unauthorized",
				"message": "Missing userId in token",
			})
			c.Abort()
			return
		}

		// Log backend token claims for debugging
		log.Printf("[AUTH] BackendAuth: Token validated successfully")
		log.Printf("[AUTH] BackendAuth: JWT Claims - userId=%s, email=%s, iat=%v, exp=%v",
			claims.UserId,
			claims.Email,
			claims.IssuedAt,
			claims.ExpiresAt,
		)

		// Store backend token claims in context (optional, for future use)
		c.Set("backendUserId", claims.UserId)
		c.Set("backendEmail", claims.Email)
		c.Set("backendClaims", claims)

		c.Next()
	}
}
